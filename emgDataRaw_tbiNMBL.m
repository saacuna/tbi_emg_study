classdef emgDataRaw_tbiNMBL < handle
    % Filename: emgDataRaw_tbiNMBL.m
    % Author:   Samuel Acuna
    % Date:     25 Jan 2016
    % Description:
    % This class file is used to store all the EMG data from a single
    % trial. The class creates a much smaller data file of the emg curves
    % for the average gait cycle of the trial, as well as collecting all
    % the trial metadata. use emg_tbiNMBL to compare emg curves between
    % trials using the data generated by this file.
    % 
    % The raw emg data must be in a .txt format, not .hpf
    % To create the .txt version, open program 'emg_works' on collection
    % computer. Do 'Cyclic analysis'. Tools ? export to text tile. Put this
    % file in the same location as the original .hpf
    %
    % Example usage:
    %       emg1 = emgDataRaw_tbiNMBL() %load emg data and calculate average emg cycle data
    %       emg1.plotGaitCycle() % plots average emg cycle data for all muscles recorded
    %       emg1.updateSubjectTrialInfo() % update any subject and trial info for file 
    %       emg1.exportEmgData() % save just avg emg cycle data, small file size, for further processing
    %       save('emg1.mat','emg1') % save raw and calculated data, so dont have to calculate again
    
    
    properties (GetAccess = 'public', SetAccess = 'private')
        % public read access, but private write access.
        
        infile; % name of original emg txt data file
        inpath; % name of directory of original emg txt data file
        
        subjectID; % e.g. TBI-06
        subjectInitials; % e.g. SA
        dateCollected; % e.g. 'nov 23, 2015'
        testPoint; % 1, 2, 6, or 10
        dataCollectedBy; % e.g. 'SA' or 'KR'
        walkingSpeed_preferred; % e.g.  2.0 mph. for testPoint 1, this is the same as the baseline.
        walkingSpeed_baseline; % e.g.  1.6 mph
        trialType; % relaxed standing, relaxed lying down, baseline preferred treadmill, new preferred treadmill, overground
        notes; % anything worth mentioning for this data (e.g. hands on treadmill)
        
        % processed data structures
        emgcyc; % normalized emg data over the average gait cycle
        emgcycstd; % standard deviationnormalized emg data over the average gait cycle
        emgcyclabel; % names of all the muscles corresponding to each column of emgcyc
        
        % raw data structures
        emg;  % structure containing the emg data
        accX; % structure containing the x-acceleration data
        accY; % structure containing the y-acceleration data
        accZ; % structure containing the z-acceleration data
        
        % each raw structure contains file name, time, and data matrix
        % e.g.
        %     emg.label
        %     emg.type
        %     emg.sensor
        %     emg.freq
        %     emg.npts
        %     emg.xstart
        %     emg.unit
        %     emg.domainunit
        %     emg.sysgain
        %     emg.adgain
        %     emg.bitres
        %     emg.bias
        %     emg.hpcutoff
        %     emg.lpcutoff
        %     emg.file
        %     emg.time
        %     emg.data
        
    end
    methods ( Access = public )
        % constructor function
        function obj = emgDataRaw_tbiNMBL(infile,inpath)
            %   Inputs (optional)
            %       infile - file to be loaded,
            %                e.g. 'test.txt'
            %                If infile is unspecified, the user is prompted to select the input file
            %       inpath - directory of location where data file is located
            %               e.g. '/Users/user1/Documents/emg_directory/'
            %               when no path is specified, it defaults to current directory
            
            narg = nargin;
            if (narg==0); % choose emg txt file
                [infile, inpath]=uigetfile('*.txt','Select input file');
                if infile == 0
                    error('Canceled. No file selected');
                end
            else % check filename and pathname are valid
                
                % append .txt if not included on infile name
                if ~strcmpi('txt',infile(end-2:end))
                    infile = [infile(1:length(infile)) '.txt'];
                end
                if (narg == 1) % if inpath not specified
                    inpath=[pwd '/']; % sets the current working directory
                else
                    if ~strcmpi(inpath(end),'/') % makes sure slash is at end of path
                        inpath = [inpath '/'];
                    end
                end
                
                % check file is in directory
                original_directory = pwd;
                try
                    cd(inpath);
                catch
                    error('inpath : directory name not valid. Fix this');
                end
                fileFound = false;
                D = dir('*.txt');
                for i = 1:length(D)
                    if strcmpi(infile,D(i).name)
                        fileFound = true;
                        break;
                    end
                end
                cd(original_directory);
                if fileFound
                    disp('file found.');
                else
                    error('infile : specified filename not found in this directory.');
                end
            end
            
            % record emg file location
            obj.infile = infile;
            obj.inpath = inpath;
            
            % generate emg, accX, accY, accZ data
            disp('loading and converting raw emg data into matlab friendly format. This might take a while...')
            try
                load_emgworks(obj,infile,inpath)
            catch
                error('could not load emgworks file. Something went wrong in the load_emgworks function.');
            end
            disp('conversion completed. now add trial data.')
            
            % record subject / trial info
            obj.subjectID = '';
            obj.subjectInitials = '';
            obj.dateCollected = '';
            obj.testPoint = '';
            obj.dataCollectedBy = '';
            obj.walkingSpeed_preferred = '';
            obj.walkingSpeed_baseline = '';
            obj.trialType = '';
            obj.notes = '';
            
            % update the trial info with metadata
            updateSubjectTrialInfo(obj);
            disp('Trial successfully loaded into memory.')
            
            % calculate emg data over the average gate cycle
            plotYes = 0; % set to true if you want to see plots of intermediate calculations
            calcEmgCycle(obj, plotYes); 
            disp('Successfully calculated EMG data for average gait cycle. Can export to saved file using exportEmgData() function')
        end
        
        
        function updateSubjectTrialInfo(obj)
            % this function asks for the subject and trial info, to store
            % along with the EMG data. If the subject and trial info has
            % already been inputted, it will update the information.
            
            % first update the general collection information
            prompt1 = {'Subject ID:   (ex: "TBI-06")',...
                'Subject Initials:   (ex: "SA")',...
                'Date Collected:   (yyyy-MM-dd)',...
                'Data Collected by:   (ex: "SA")',...
                'Preferred walking speed:   (ex: "2.1 mph")',...
                'Baseline walking speed:   (ex: "2.0 mph")'};
            prompt1_defaultAnswer = {obj.subjectID,obj.subjectInitials,obj.dateCollected,obj.dataCollectedBy,obj.walkingSpeed_preferred,obj.walkingSpeed_baseline};
            prompt1_title = 'Collection Information';
            prompt1_answer = inputdlg(prompt1,prompt1_title,[1 60],prompt1_defaultAnswer);
            if isempty(prompt1_answer); return; end; % user canceled. bail out.
            % update collection info
            obj.subjectID = prompt1_answer{1};
            obj.subjectInitials = prompt1_answer{2};
            obj.dateCollected = prompt1_answer{3};
            obj.dataCollectedBy = prompt1_answer{4};
            obj.walkingSpeed_preferred = prompt1_answer{5};
            obj.walkingSpeed_baseline = prompt1_answer{6};
            
            % second, update the test point for which the trial was collected.
            testPoints = {'01','02','06','10'};
            prompt2_defaultAnswer = find(strcmp(obj.testPoint,testPoints)==1); % find default answer
            if isempty(prompt2_defaultAnswer); prompt2_defaultAnswer = 1; end; % if setting for first time
            prompt2_title = 'Select Test Point:';
            prompt2_title2 = 'Test Point';
            prompt2_answer = listdlg('PromptString',prompt2_title,'SelectionMode','single','Name',prompt2_title2,'ListString',testPoints,'InitialValue',prompt2_defaultAnswer,'ListSize',[150 75]);
            if isempty(prompt2_answer); return; end; % user canceled. bail out.
            % update test point
            obj.testPoint = testPoints{prompt2_answer};
            
            % third, update specific trial info
            trials = tbiConstants.trialType;
            prompt3_defaultAnswer= find(strcmp(obj.trialType,trials)==1);
            if isempty(prompt3_defaultAnswer); prompt3_defaultAnswer = 1; end; % if setting for first time
            prompt3_title = 'Select Trial Type:';
            prompt3_title2 = 'Trial Type';
            prompt3_answer = listdlg('PromptString',prompt3_title,'SelectionMode','single','Name',prompt3_title2,'ListString',trials,'InitialValue',prompt3_defaultAnswer,'ListSize',[150 75]);
            if isempty(prompt3_answer); return; end; % user canceled. bail out.
            % update trial type
            obj.trialType = trials{prompt3_answer};
            
            % fourth, update any additional notes for each trial
            prompt4 = {'Trial Notes:   (ex: "hands on treadmill")'};
            prompt4_defaultAnswer = {obj.notes};
            prompt4_title = 'Additional trial notes';
            prompt4_answer = inputdlg(prompt4,prompt4_title,[5 50],prompt4_defaultAnswer);
            if isempty(prompt4_answer); return; end; % user canceled. bail out.
            % update additional notes
            obj.notes = prompt4_answer{1};
        end
        
        
        function exportEmgData(obj)
            % this function saves just the avg emg gait cycle data. its a
            % small file size, and all you really need. Useful for
            % comparisons, and principle component analysis, as well as
            % synergy analysis using non negative matrix factorization
            
            % create save file name
            tbiNum_index = regexp(obj.subjectID, '\d');
            defaultFilename = ['emg_tbi' obj.subjectID(tbiNum_index) '_tp' obj.testPoint '_' obj.trialType '.mat'];
      
            % dialog box for saving file
            [filename, filepath, FilterIndex] = uiputfile('*.mat','Save emg gait cycle data as...',defaultFilename);
            
            if FilterIndex ~= 0 % if user did not cancel saving
                
                %create data structure of emg cycle data
                emgcyc = struct(...
                    'subjectID', {obj.subjectID},...
                    'subjectInitials', {obj.subjectInitials},...
                    'dateCollected', {obj.dateCollected},...
                    'testPoint', {obj.testPoint},...
                    'dataCollectedBy', {obj.dataCollectedBy},...
                    'walkingSpeed_preferred', {obj.walkingSpeed_preferred},...
                    'walkingSpeed_baseline', {obj.walkingSpeed_baseline},...
                    'trialType', {obj.trialType},...
                    'notes', {obj.notes},...
                    'emg', {obj.emgcyc},...
                    'emgstd', {obj.emgcycstd},...
                    'emglabel', {obj.emgcyclabel},...
                    'emgfreq', {obj.emg.freq});
                orig_dir = pwd;
                cd(filepath);
                save(filename,'emgcyc') % save file
                cd(orig_dir);
                disp(['Data saved as ' filename]);
            end    
        end
        
        function plotGaitCycle(obj)
            % this function plots the emg gait cycle data for the
            % calculated trial. cool, eh?
            %Plots 2 figures, each with 6 muscles (mean +/- std)

            % RIGHT LEG
            figure()
            for j=1:6
                subplot(6,1,j);
                hold on
                rightleg=shadedErrorBar([0:100]',obj.emgcyc(:,j),obj.emgcycstd(:,j),'b',1);
                plot([0:100]',obj.emgcyc(:,j),'b');
                hold off
                title(obj.emgcyclabel(j));
                ylim([0,3]);
                xlabel('Percent of Gait Cycle');
                %axis([0,100,0,inf]);
            end
            % LEFT LEG
            figure()
            for j=1:6
                subplot(6,1,j);
                hold on
                leftleg=shadedErrorBar([0:100]',obj.emgcyc(:,6+j),obj.emgcycstd(:,6+j),'b',1);
                plot([0:100]',obj.emgcyc(:,6+j),'b');
                hold off
                title(obj.emgcyclabel(6+j));
                ylim([0,3]);
                xlabel('Percent of Gait Cycle');
                %axis([0,100,0,inf]);
            end
            
        end
    end
    
    methods ( Access = private )
        function load_emgworks(obj, infile,inpath)
            %   [emg,ax,ay,az]=load_emgworks(infile,inpath)
            %   LOAD_EMGWORKS is used to open a csv formateed data file generated by the emgworks
            %   software
            %
            %   Inputs
            %       infile - file to be loaded
            %       inpath - directory of location where data file is located
            %
            %   Outputs:
            %       emg   structure containing the emg data
            %       ax   structure containing the x-acc data
            %       ay   structure containing the y-acc data
            %       az   structure containing the z-acc data
            %
            %       each structure contains file name, time, and data matrix
            %       e.g.      emg.file, emg.time, emg.data
            
            fid = fopen([inpath infile],'r');
            if (fid==-1);
                disp('File not found');
                return;
            end
            
            
            % Read in the channel labels first
            line=fgetl(fid);
            nch=0; npts=0; maxpts=0;
            while (line(1:5)~='Start')
                jcolon=find(line==':');
                line(jcolon(2)+6:jcolon(2)+10);
                nch=nch+1;
                ch(nch)=readhdr(line,fid,nch);
                if (ch(nch).npts>maxpts), maxpts=ch(nch).npts;  end
                npts=npts+ch(nch).npts;
                line=fgetl(fid);
            end
            
            % Read down to start of data
            while (line(1)~='X')
                line=fgetl(fid);
            end
            
            % Read in all the data at once
            data=zeros(maxpts,2*nch);
            k=1;
            while ~feof(fid)
                line=fgetl(fid);
                % find then eliminate commas
                jc=[0 find(line==',') length(line)+1];
                line(line==',')=' ';
                % find units
                units=line(jc(2:end)-1);
                %     % now eliminate unit signs
                line(line=='m')=' ';
                line(line=='µ')=' ';
                line(line=='n')=' ';
                line(line=='p')=' ';
                line(line=='f')=' ';
                % figure out where the data goes
                kk=(diff(jc)>1);
                data(k,kk)=sscanf(line,'%f',[1 length(kk)]);
                km=(units=='m');  data(k,km)=data(k,km)*.001;
                ku=(units=='µ');  data(k,ku)=data(k,ku)*.000001;
                kn=(units=='n');  data(k,kn)=data(k,kn)*.000000001;
                kp=(units=='p');  data(k,kp)=data(k,kp)*.000000000001;
                kf=(units=='f');  data(k,kf)=data(k,kf)*.000000000000001;
                %    disp(data(k,:));
                % disp(['line ',num2str(k),' time ',num2str(data(k,1))]);
                k=k+1;
            end
            
            % Now distribute the data
            jemg=[]; jax=[]; jay=[]; jaz=[];
            for i=1:nch
                if strmatch('EMG',ch(i).type); jemg=[jemg i]; end
                if strmatch('ACC X',ch(i).type); jax=[jax i]; end
                if strmatch('ACC Y',ch(i).type); jay=[jay i]; end
                if strmatch('ACC Z',ch(i).type); jaz=[jaz i]; end
            end
            file=[inpath infile];
            obj.emg=ch(jemg);
            for i=1:length(obj.emg); obj.emg(i).file=file;  obj.emg(i).time=data(1:obj.emg(i).npts,jemg(i)*2-1);   obj.emg(i).data=data(1:obj.emg(i).npts,jemg(i)*2); end
            obj.accX=ch(jax);
            for i=1:length(obj.accX); obj.accX(i).file=file;   obj.accX(i).time=data(1:obj.accX(i).npts,jax(i)*2-1);   obj.accX(i).data=data(1:obj.accX(i).npts,jax(i)*2); end
            obj.accY=ch(jay);
            for i=1:length(obj.accY); obj.accY(i).file=file;   obj.accY(i).time=data(1:obj.accY(i).npts,jay(i)*2-1);   obj.accY(i).data=data(1:obj.accY(i).npts,jay(i)*2); end
            obj.accZ=ch(jaz);
            for i=1:length(obj.accZ);  obj.accZ(i).file=file;  obj.accZ(i).time=data(1:obj.accZ(i).npts,jaz(i)*2-1);   obj.accZ(i).data=data(1:obj.accZ(i).npts,jaz(i)*2); end
            clear ch;
            clear data;
            fclose(fid);
            
        end
        
        function calcEmgCycle(obj, plots)
            % this function takes the loaded raw emg data, and calculates
            % the data for the average emg for the gait cycle. this is a much smaller
            % amount of data to keep in memory
            
            % plots = 0 or 1, depending if you want plots accompanying the
            % calculation
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Finds the peaks of the filtered acc data
            
            [bfa,afa]=butter(3,25/(obj.accX(1).freq/2));
            
            
            for i=1:3
                axf=filtfilt(bfa,afa,obj.accX(i).data);
                ayf=filtfilt(bfa,afa,obj.accY(i).data);
                azf=filtfilt(bfa,afa,obj.accZ(i).data);
                amag(:,i)=(obj.accX(i).data.^2+obj.accY(i).data.^2+obj.accZ(i).data.^2).^0.5;
                amagf(:,i)=(axf.^2+ayf.^2+azf.^2).^0.5;
            end
            
            if plots
                figure()
                for i = 1:3
                    subplot(4,1,i);
                    %Plots the raw acc data of x,y,z for each ankle and lumbar
                    plot(obj.accX(1).time,[obj.accX(i).data obj.accY(i).data obj.accZ(i).data]);
                    hold on;
                    %Plots the filtered acc data of x,y,z for each ankle and lumbar
                    %overlayed as dashes
                    plot(obj.accX(1).time,[axf ayf azf],'--');
                    hold off
                    title(obj.accX(i).label);
                    legend('accX_raw', 'accY_raw', 'accz_raw','accX_filt','accY_filt','accZ_filt');
                end
                
            end
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Uses the magnitudes from filtered acc data and finds the peaks
            
            [hsr, hsrp]=findpeaks(amagf(:,1),'MinPeakHeight',2.,'MinPeakDistance',100); % [heel strike right ankle, time of strike]
            [hsl, hslp]=findpeaks(amagf(:,2),'MinPeakHeight',2.,'MinPeakDistance',100); % [heel strike left ankle, time of strike]
            
            if plots
                % Plots the peaks as x's and o's
                subplot(4,1,4);
                plot(obj.accX(1).time,amagf,'-');
                hold on;
                plot(obj.accX(1).time(hsrp),hsr, 'o');
                plot(obj.accX(1).time(hslp),hsl,'x');
                hold off;
                legend('R Ankle', 'L Ankle', 'Lumbar')
                title('Peaks of Acceleration Magnitudes, filtered')
            end
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Filter the EMG data
            % Use 3 filters to remove non-EMG frequency range noise, drift, and
            % then get nice activation envelopes - numbers are set for 2000 Hz
            % collection
            [b,a]=butter(4,0.35,'low'); %Used to remove high-frequency noise above 350Hz
            [bb,aa]=butter(4,0.001,'high'); %Used to remove low-frequency drift below 1Hz
            [bbb,aaa]=butter(4,0.01,'low'); %Used to filter to 10Hz to get envelope
            for ii=1:12
                emgdatar(:,ii)=obj.emg(ii).data; %Raw emg data - Here just pulling the matrix of data out of the structure I loaded
                emgdatalabel{ii}=obj.emg(ii).label;
            end
            EMfr=filtfilt(bb,aa,emgdatar); %Zero-shift filter removing drift first
            EMGr=filtfilt(b,a,EMfr); %Zero-shift filter removing high frequency noise
            EMGabs=abs(EMGr); %Rectify data
            emgdata=filtfilt(bbb,aaa,EMGabs); %Filter to envelopes of activation

            if plots % plots the filtered emg data
                figure()
                for i = 1:12
                    subplot(12,1,i);
                    plot(obj.emg(1).time,emgdata(:,i));
                    title(obj.emg(i).label);
                end
            end
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %Computes the average emg cycle
            emgtime=obj.emg(1).time;
            for j=1:6
                emgc(j)=avgcycle(emgtime,emgdata(:,j),obj.accX(1).time(hsrp),10,50); %right leg muslces
                emgc(6+j)=avgcycle(emgtime,emgdata(:,6+j),obj.accX(2).time(hslp),10,50); % left leg muscles
                emgclabel(j)=emgdatalabel(j);
                emgclabel(6+j)=emgdatalabel(6+j);
            end
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %Normalize the EMG data
            for j=1:12
                emgrms(j)=rms(emgdata(:,j));
                
                normemg(:,j)=(emgc(j).avg)./(emgrms(j));
                normemgstd(:,j)=(emgc(j).sd)./(emgrms(j));
                normemglabel(j) = emgclabel(j);
            end

            obj.emgcyc = normemg;
            obj.emgcycstd = normemgstd;
            obj.emgcyclabel = normemglabel;
        end
    end
end

% local functions only (within this m-file)
function hdr = readhdr(line,fid,nch)
position = ftell(fid);
jcolon=find(line==':');
hdr.label=sscanf(line(jcolon(1)+1:jcolon(2)-1),'%s%c');
hdr.type=sscanf(line(jcolon(2)+6:jcolon(3)-1),'%s%c');
if strmatch('EMG',hdr.type(1:3)) hdr.sensor=sscanf(hdr.type(4:end),'%d');  hdr.type=hdr.type(1:3); end
if strmatch('ACC',hdr.type(1:3)) hdr.sensor=sscanf(hdr.type(6:end),'%d');  hdr.type=hdr.type(1:5);   end
hdr.freq=sscanf(line(jcolon(3)+1:end),'%f');
hdr.npts=sscanf(line(jcolon(4)+1:end),'%f');
hdr.xstart=sscanf(line(jcolon(5)+1:end),'%f');
hdr.unit=sscanf(line(jcolon(6)+1:end),'%s');
hdr.domainunit=sscanf(line(jcolon(7)+1:end),'%s');
n=0;
while(n<nch)
    line=fgetl(fid);
    if strmatch('System',line);
        n=n+1;
    end
end
jcolon=find(line==':'); hdr.sysgain=sscanf(line(jcolon+1:end),'%f');
line=fgetl(fid);    jcolon=find(line==':'); hdr.adgain=sscanf(line(jcolon+1:end),'%f');
line=fgetl(fid);    jcolon=find(line==':'); hdr.bitres=sscanf(line(jcolon+1:end),'%f');
line=fgetl(fid);    jcolon=find(line==':');	hdr.bias=sscanf(line(jcolon+1:end),'%f');
line=fgetl(fid);    jcolon=find(line==':');	hdr.hpcutoff=sscanf(line(jcolon+1:end),'%f');
line=fgetl(fid);    jcolon=find(line==':');	hdr.lpcutoff=sscanf(line(jcolon+1:end),'%f');
fseek(fid,position,'bof');
end

function xc=avgcycle(time,x,tc,hcf,lcf)
% xc=avgcycle(x,tc,hcf,lcf)
npts=101;
% if (length(hcf)>0)
%     [bhf,ahf]=butter(3,hcf/(x.freq/2),'high');
%     xf=filtfilt(bhf,ahf,x.data);
% else
%     xf=x.data;
% end
% if (length(lcf)>0)
%     [blf,alf]=butter(3,lcf/(x.freq/2));
%     xf=filtfilt(blf,alf,abs(xf));
% end
xf=x;
xc.cycles=zeros(npts,size(tc,1));
for j=1:length(tc)-1
    j1=find(time>tc(j));  j1=j1(1);
    j2=find(time>tc(j+1));  j2=j2(1);
    xc.cycles(:,j)=normcycle(xf(j1:j2),npts);
    xc.period(j)=time(j2)-time(j1);
end
xc.avg=mean(xc.cycles')';
xc.sd=std(xc.cycles')';
% xc.label=x.label;
end

function yf = normcycle(y,n,x)
% yf = normcycle(y,n,x)
% Convert a signal y to n even-spaced data points over a cycle
% Often used for presentation of gait data, default for n is 101 points
% can specify an indpendent variable x (optional)
if ~exist('n','var')
    n=101;
end
[nr,nc]=size(y);
if nc==1 && nr>1
    ny=1;
    nx=nr;
elseif nr==1 && nc>1
    y=y';
    ny=1;
    nx=nc;
elseif nr>1 && nc>1
    ny=nc;
    nx=nr;
else
    disp('normcycle does not work on a scalar value');
    yf=[];
    return
end
if ~exist('x','var')
    x=[0:(nx-1)]/(nx-1);
else
    nx=length(x);
    x=(x-x(1))/(x(end)-x(1));
end
kk=[0:(n-1)]/(n-1);
yf=interp1(x,y,kk,'*pchip');

end
